# ДЗ условие (решение ниже)

## ДЗ -- часть 1

За каждый пункт - 1 балл

Внедрить во вторую домашку хранение данных в БД, для этого надо:
1) Добавить БД в docket-compose.yml (если БД - это отдельный сервис, если хотите использовать sqlite, то можно скипнуть этот шаг)
2) Переписать код на взаимодействие с вашей БД (если вы еще этого не сделали, если вы уже написали код с БД, подзравляю, вам остался только 3 пункт)
3) В свободной форме, напишите скрипты, которые просимулируют разные "проблемы" которые могут возникнуть в транзакциях (dirty read, not-repeatable read, serialize) и настраивая уровне изоляции покажите, что они действительно решаются (через SQLAlchemy например), то есть:
показать dirty read при read uncommited
показать что нет dirty read при read commited
показать non-repeatable read при read commited
показать что нет non-repeatable read при repeatable read
показать  phantom reads при repeatable read
показать что нет phantom reads при serializable
*Тут зависит от того какую БД вы выбрали, разные БД могут поддерживать разные уровни изоляции


## ДЗ -- часть 2

1) Добиться 95% покрытия тестами вашей второй домашки - 1 балл
2) Настроить автозапуск этих тестов в CI, если вы подключали сторонюю БД, то можно посмотреть вот [сюда](https://dev.to/kashifsoofi/integration-test-postgres-using-github-actions-3lln), чтобы поддержать тесты с ней в CI. По итогу у вас должен получится зеленый пайплайн - оценивается в еще 2 балла.

# Решение

## Часть 1: Миграция на БД и демонстрация транзакций

1. База данных (SQLite)

- Добавлена SQLite (не требует docker-compose, т.к. это файловая БД)
- Созданы модели SQLAlchemy: items, carts, cart_items
- Файлы: shop_api/database.py, обновлён shop_api/main.py

2. Миграция кода

- Все эндпоинты переписаны на работу с БД
- Все оригинальные тесты проходят
- Используются контекстные менеджеры для транзакций

3. Демонстрация проблем транзакций

Создано 6 скриптов в `transaction_demos/`:
- `01_dirty_read_demo.py` - показывает dirty read при READ UNCOMMITTED
- `02_no_dirty_read_demo.py` - нет dirty read при READ COMMITTED
- `03_non_repeatable_read_demo.py` - показывает non-repeatable read
- `04_no_non_repeatable_read_demo.py` - нет non-repeatable read при REPEATABLE READ
- `05_phantom_read_demo.py` - показывает phantom reads
- `06_no_phantom_read_demo.py` - нет phantom reads при SERIALIZABLE

Запустить все:
```
python transaction_demos/run_all_demos.py
```
**Описание проблем**

  1. Dirty Read (Грязное чтение)

  `01_dirty_read_demo.py` - Проблема:
  - Транзакция T1 обновляет баланс с 1000 на 500, но НЕ коммитит
  - Транзакция T2 читает баланс и видит 500 (незакоммиченное значение)
  - T1 делает ROLLBACK
  - Результат: T2 прочитала данные, которых "никогда не было" (они откатились)

  `02_no_dirty_read_demo.py` - Решение (READ COMMITTED):
  - T1 обновляет баланс на 500, не коммитит
  - T2 пытается прочитать, но видит только закоммиченное значение 1000
  - T1 откатывается
  - Результат: T2 всегда видит только подтверждённые данные

  2. Non-Repeatable Read (Неповторяющееся чтение)

  `03_non_repeatable_read_demo.py` - Проблема:
  - T1 читает баланс: получает 1000
  - T2 обновляет баланс на 1500 и COMMIT
  - T1 снова читает баланс: получает 1500
  - Результат: в одной транзакции T1 одно и то же чтение дало разные результаты (1000 → 1500)

  `04_no_non_repeatable_read_demo.py` - Решение (REPEATABLE READ / IMMEDIATE):
  - T1 начинает транзакцию с блокировкой (BEGIN IMMEDIATE)
  - T1 читает баланс: 1000
  - T2 пытается обновить, но блокируется из-за блокировки T1
  - T1 снова читает баланс: всё ещё 1000
  - T1 коммитит, только потом T2 может обновить
  - Результат: повторные чтения в T1 возвращают одинаковые значения

  3. Phantom Read (Фантомное чтение)

  `05_phantom_read_demo.py` - Проблема:
  - T1 выполняет запрос: "SELECT * WHERE balance > 500" → находит 2 строки (Alice, Bob)
  - T2 вставляет новую строку Charlie с балансом 1500 и COMMIT
  - T1 повторяет запрос: "SELECT * WHERE balance > 500" → находит 3 строки (Alice, Bob, Charlie)
  - Результат: в одной транзакции появились "фантомные" строки, которых раньше не было

  `06_no_phantom_read_demo.py` - Решение (SERIALIZABLE / EXCLUSIVE):
  - T1 начинает с эксклюзивной блокировкой (BEGIN EXCLUSIVE)
  - T1 выполняет запрос: находит 2 строки
  - T2 пытается вставить новую строку, но блокируется
  - T1 повторяет запрос: всё ещё 2 строки
  - T1 коммитит, только потом T2 может вставить
  - Результат: результаты запросов в T1 стабильны, новые строки не появляются

Все скрипты используют threading для имитации параллельных транзакций и time.sleep() для синхронизации действий.


## Часть 2: Покрытие тестами и CI/CD

1. Покрытие тестами: 98% (требовалось 95%)

- Создано 14 дополнительных тестов в test_edge_cases.py
- Создано 5 WebSocket тестов в test_websocket.py
- Всего 58 тестов, все проходят

**Тесты:**
- test_homework2.py - оригинальные тесты
- test_edge_cases.py - новые edge case тесты
- test_websocket.py - тесты WebSocket


2. CI/CD для GitHub Actions

- Создан .github/workflows/test.yml
- Автоматический запуск тестов при push/PR
- Проверка покрытия ≥95%
- Запуск демонстраций транзакций


CI/CD:
- `.github/workflows/hw4-tests.yml` - GitHub Actions


# Check

## Запустить тесты
```
export PYTHONPATH=${PWD}
pytest --cov=shop_api --cov-fail-under=95 test_homework2.py test_edge_cases.py test_websocket.py
```
  
## Запустить демонстрацию транзакций
```
python transaction_demos/run_all_demos.py
```
